bb# 모노레포

## 모노레포란?

하나의 레포에 관계가 잘 정리된 여러개의 프로젝트를 포함하는 것을 의미한다.

### 그저 코드가 함께 있는게 아니다

![compare monolith and modular](https://monorepo.tools/images/monolith-modular.svg)
여러 프로젝트가 한 곳에 있는 저장소를 생각해보자. 분명하게 코드가 함께 있지만 잘 정리된 관계가 존재하지 않다면 이를 `monorepo`라고 부르지는 않는다.

이처럼, 하나의 레포가 수많은 프로젝트를 명확한 분할과 캡슐화를 적용하지 않았다면 이는 `monorepo`라고 불릴 수 없다.

> ### 👏 `Monorepo` ≠ `Monolith`
>
> 좋은 `monorepo`는 `monolith`의 정 반대다. 차차 알아보자.
>
> ---

### `Polyrepo`

설명의 간편함을 위해 `monorepo`의 반대를 `polyrepo`라고 하자. `polyrepo`는 현재 앱을 개발하는 표준이다: 각 프로젝트, 앱, 또는 팀 마다 레포를 가진다. 각각의 레포가 각각의 빌드 시스템과 파이프 라인을 가지는게 보편적이다.

![polyrepo](https://monorepo.tools/images/polyrepo-practice.svg)

수많은 업계가 `polyrepo`를 이용하는 이유는 단 한가지 다: **팀 자율성**. 팀들은 어떤 라이브러리를 사용할지, 언제 앱 또는 라이브러리를 배포할지, 또는 누가 코드를 사용하거나 기여할지에 대해서 스스로 정하고 싶어 한다.

![spectrum applied to the real world](https://monorepo.tools/images/spectrum-real-world.svg)

그러한 방식은 좋다. 그런데 모든 팀들이 각자의 방식을 가지는게 좋을까? `polyrepo`에서의 자율성은 **독립성**에서 부터 온다. 그리고 이 독립성은 협업을 해치는 요소다. 이는 `polyrepo`의 흔한 부작용이다.

### Polyrepo 의 문제점

1. 코드 공유가 귀찮다.
   다른 레포들에 공유되는 코드를 개발하기 위해서 코드 공유를 위한 레포를 따로 만들 가능성이 크다. 그리고 해당 레포에 대한 tool 과 CI 환경을 설정하고 package 배포 설정을 할거다. 이 과정을 거치더라도 버전이 호환되지 않아 공유하기 쉽지 않을거다.

2. 코드의 중복이 많다.
   코드의 중복을 해결하려고 새로운 레포를 만들고 작업하는 것은 귀찮다. 그렇기에 각 팀은 각자의 레포에 컴포넌트나 함수 등의 코드를 그냥 작성한다. 이렇게 하게 될 경우 유지보수 하기도 힘들고 서비스 변경에 대응하기도 힘들어진다.

3. 변경점이 공유된 라이브러리와 사용자 모두에게 비용이 든다.
   공유하는 라이브러리에서 심각한 버그가 발견되어 수정해야 하는 경우 이를 사용하는 모든 레포에서 사용할 수 있도록 수정 해 줘야 한다.

4. 프로젝트마다 일관성이 없다.
   각 프로젝트마다 린팅, 빌드, 테스트 등의 방법이 다르다. 이러한 다른 점들의 모두 기억하는건 정신적으로 피로하다.

## Monorepo

`monorepo`를 사용하면 이러한 문제들을 해결할 수 있다.

1. 새로운 프로젝트를 만드는데 오버헤드가 없다.
   기존에 존재하는 CI를 사용하면 된다. 모두가 같은 레포에 있다면 패키지를 버저닝 하며 배포할 필요가 없다.

2. 프로젝트 전반에 아토믹한 커밋을 할 수 있다.
   모든 커밋이 모두에게 공유된다. 하나의 커밋에 모든 변경 사항이 담기기 때문에 Breaking change가 없다.
   <br/>
   <details>
     <summary><strong>아토믹한 커밋이 좋은 이유</strong></summary>
     "원자적 커밋(Atomic commits)"은 개별 커밋이 완전하고 독립적인 기능을 가지며, 이 커밋 하나만으로도 프로젝트의 일관성과 안정성이 유지된다는 개념입니다. 즉, 한 커밋에 모든 관련 변경사항을 포함시켜 프로젝트 전체가 항상 잘 작동하도록 보장합니다. 이러한 접근 방식의 장점은 다음과 같습니다:
     통합성(Integrity): 커밋마다 전체 시스템이 제대로 작동함을 보장하기 때문에, 버전 간의 호환성 문제가 적어집니다. 어느 시점의 코드를 가져와도 시스템이 정상적으로 작동해야 합니다.
     추적 용이성(Traceability): 문제가 발생했을 때, 그 원인을 찾기 위해 검토해야 하는 커밋의 수가 줄어듭니다. 각 커밋이 완결성을 가지므로, 어떤 변경이 시스템에 영향을 미쳤는지 명확하게 추적할 수 있습니다.
     테스트 용이성(Testability): 모든 커밋에서 시스템이 올바르게 작동한다면, 지속적인 통합(CI) 과정에서의 테스트 부담이 줄어듭니다. 각 커밋은 자체적으로 완전한 기능을 제공해야 하므로, 별도의 테스트 없이도 안정성을 보장할 수 있습니다.
     이와 같이 원자적 커밋은 소프트웨어 개발에서 큰 프로젝트를 관리하는 데 있어 중요한 방법론이 될 수 있습니다. 각 커밋이 전체적으로 영향을 미치고, 모든 변경이 한번에 처리되어야 하는 큰 시스템이나 모노레포 구조에서 특히 유용합니다.
   </details>
   </br>
3. 하나의 버전만 존재한다.
   여러개의 프로젝트에서 다른 버전의 라이브러리를 사용함으로 인해 생기는 호환성 문제를 걱정할 필요가 없다.

4. 개발 이동성
   다른 툴과 기술로 작성된 앱에 대해서 일관적으로 테스팅 하고 빌딩 할 수 있다. 뿐만 아니라 다른 프로젝트에 자신있게 기여할 수 있다.

### Monorepo 특징

**모노레포 툴은 어떤 기능을 제공해야 하는가**
모노레포는 다양한 이점을 제공하지만 이를 제대로 활용하려면 적절한 툴을 사용해야 한다. 툴은 워크스페이스의 규모가 커지더라도 워크스페이스가 여전히 빠르고 유지보수하기 쉽고 관리하기 쉽게 만들어 준다.

1. Local computation caching (로컬 계산 캐싱)
2. Local task orchestration (로컬 태스크 협주)
3. Distributed computation caching (분산화된 계산 캐싱)
4. Distributed task execution (분산화된 태스크 실행)
5. Transparent remote execution (투명한 원격 실행)
6. Detecting affected projects/packages (영향받은 프로젝트/패키지 감지)
7. Workspace analysis (워크스페이스 분석)
8. Dependency graph visualization (의존성 그래프 시각화)
9. Code sharing (코드 공유)
10. Consistent tooling (기술 일관화)
11. Code generation (코드 생성)
12. Project constraints and visibility (프로젝트 제약성과 가시성)

## 출처

[monorepo.tools](https://monorepo.tools/#monorepo-features)
